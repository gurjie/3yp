/*
	 * public void disasm2(int address, ArrayList<CsInsn> instrList) { if
	 * (this.knownAddresses.contains(address)) { System.out.println(address +
	 * "was already disassembled, so what now?"); return; } do { Capstone.CsInsn
	 * instruction; instruction = disasmInstructionAtAddress(address, data, entry,
	 * textSize); System.out.printf("0x%x:\t%s\t%s\n",(int) instruction.address,
	 * instruction.mnemonic, instruction.opStr); instrList.add(instruction); /*if
	 * (isReturnInstruction(instruction)) { return current; } else if
	 * (isUnconditionalCti(instruction)) { int destinationAddr =
	 * getTargetAddress(instruction); if (destinationAddr != -1) { if
	 * (destinationAddr < entry || destinationAddr > entry+textSize) { int
	 * continueAddr = address + instruction.size; return current; } else {
	 * current.addAddressReference(getTargetAddress(instruction)); return
	 * disasm(getTargetAddress(instruction)); } } else {
	 * current.addPtrReference(instruction.opStr); } }
	 * 
	 * if (isConditionalCti(instruction)||isUnconditionalCti(instruction)) {
	 * ArrayList<Integer> possibleTargets = new ArrayList<Integer>(); int jumpAddr =
	 * getTargetAddress(instruction); // determine CTI destination if (jumpAddr !=
	 * -1) { // if dest can be reached possibleTargets.add(jumpAddr); // one target
	 * to disassemble at } else { return; } //int continueAddr = address +
	 * instruction.size; // diasm at enxt inst address
	 * //possibleTargets.add(continueAddr); // add next address to possible target
	 * for (int addr : possibleTargets) { // for all possible disassemble targets
	 * /*if (this.knownAddresses.contains(addr)) { // if the address hasn't been
	 * disasm already System.out.println(addr +" already disassembled"); continue;
	 * // skip to the next disasm target } disasm2(addr, this.instrList); // disasm
	 * at first address (recursive) } } else { // its not a CTI so disasm next
	 * address += instruction.size; }
	 * 
	 * } while (address <= entry + textSize); }
	 */
	 
	 
	 	public BasicBlock disasm(int address) {
		BasicBlock current = new BasicBlock();
		if (this.possibleTargets.size() == 0) {
			return current;
		}
		this.blockList.add(current);
		do {
			if (address == 9432) {
			}
			Capstone.CsInsn instruction;
			instruction = disasmInstructionAtAddress(address, data, entry, textSize);
			// if(instruction == null) {
			// break;
			// }
			if (instruction == null) {
				break;
			}
			System.out.printf("0x%x:\t%s\t%s\n", (int) instruction.address, instruction.mnemonic, instruction.opStr);
			current.addInstruction(instruction);

			if (instruction.mnemonic.equals("ret")) {
				return disasm(address + instruction.size);
			}

			if (isConditionalCti(instruction) || isUnconditionalCti(instruction)) {
				int jumpAddr = getTargetAddress(instruction); // determine CTI destination
				if (jumpAddr != -1) { // if dest can be reached
					if (jumpAddr >= entry && jumpAddr <= entry + textSize) { // if within text section
						current.addAddressReference(jumpAddr); // ignore for now
						possibleTargets.add(jumpAddr); // one target to disassemble at
					} else {
						address += instruction.size; // if its outside of scope of text disasm next
						continue;

					}
				} else {
					current.addPtrReference(instruction.opStr);
				}
				int continueAddr = address + instruction.size; // diasm at enxt inst address
				possibleTargets.add(continueAddr); // add next address to possible target
				current.addAddressReference(continueAddr); // ignore for now
				int target = this.possibleTargets.get(0);
				return disasm(this.possibleTargets.get(0));
			} else { // its not a CTI so disasm next
				address += instruction.size;
			}

		} while (address < entry + textSize);
		return current;
	}
	
	
	
	private void openCFG() {
		view.getGraphPane().removeAll();
		// initialise the control flow graph shower
		// start the popup CFG with model.showCfg as input, which returns a string
		this.graph = new mxGraph();
		Object parent = graph.getDefaultParent();
		graph.getModel().beginUpdate();
		try {
			Object v1 = graph.insertVertex(parent, null, "asflfsaljiasflij\nflifjliadg", 20, 20, 80, 30);
			Object v2 = graph.insertVertex(parent, null,
					"Worl\nfaelijafijldgajil\nfailaf\nfkaafs\nfakjnfask\nfajkfsfas!", 240, 150, 80, 30);
			Object v3 = graph.insertVertex(parent, null,
					"Worl\nfaelijafijldgajil\nfailaf\nfkaafs\nfakjnfask\nfajkfsfas!", 320, 180, 80, 30);
			Object v4 = graph.insertVertex(parent, null, "1", 370, 250, 80, 30);
			Object v5 = graph.insertVertex(parent, null, "2", 370, 250, 80, 30);
			Object v6 = graph.insertVertex(parent, null, "3", 370, 250, 80, 30);
			Object v7 = graph.insertVertex(parent, null, "4", 370, 250, 80, 30);
			Object v8 = graph.insertVertex(parent, null, "5", 370, 250, 80, 30);
			Object v9 = graph.insertVertex(parent, null, "6", 370, 250, 80, 30);
			Object v10 = graph.insertVertex(parent, null, "7", 370, 250, 80, 30);
			Object v11 = graph.insertVertex(parent, null, "5", 370, 250, 80, 30);
			Object v12 = graph.insertVertex(parent, null, "6", 370, 250, 80, 30);
			Object v13 = graph.insertVertex(parent, null, "7", 370, 250, 80, 30);
			Object v14 = graph.insertVertex(parent, null, "5", 370, 250, 80, 30);
			Object v15 = graph.insertVertex(parent, null, "6", 370, 250, 80, 30);
			Object v16 = graph.insertVertex(parent, null, "7", 370, 250, 80, 30);
			Object v17 = graph.insertVertex(parent, null, "5", 370, 250, 80, 30);
			Object v18 = graph.insertVertex(parent, null, "6", 370, 250, 80, 30);
			Object v19 = graph.insertVertex(parent, null, "7", 370, 250, 80, 30);

			graph.setCellsResizable(true);
			graph.updateCellSize(v2);
			graph.insertEdge(parent, null, "", v1, v2);
			graph.insertEdge(parent, null, "", v2, v3);
			graph.insertEdge(parent, null, "", v1, v4);
			graph.insertEdge(parent, null, "", v8, v5);
			graph.insertEdge(parent, null, "", v5, v6);
			graph.insertEdge(parent, null, "", v7, v1);
			graph.insertEdge(parent, null, "", v9, v1);
			graph.insertEdge(parent, null, "", v1, v7);
			graph.insertEdge(parent, null, "", v4, v1);
			graph.insertEdge(parent, null, "", v7, v8);
			graph.insertEdge(parent, null, "", v1, v9);
			graph.insertEdge(parent, null, "", v4, v10);

			graph.setCellsDisconnectable(false);
			graph.setEdgeLabelsMovable(false);

			System.out.println("built!");
		} finally {
			graph.getModel().endUpdate();
		}
		mxGraphComponent graphComponent = new mxGraphComponent(graph);
		graphComponent.getGraphControl().addMouseListener(new MouseAdapter() {
			public void mouseReleased(MouseEvent e) {
				Object cell = graphComponent.getCellAt(e.getX(), e.getY());
				if (cell != null) {

					System.out.println("cell=" + graph.getLabel(cell));
				}
			}
		});
		mxIGraphLayout layout = new mxHierarchicalLayout(graph);
		layout.execute(graph.getDefaultParent());
		// graph.groupCells();
		graph.setCellsEditable(false);
		graphComponent.setConnectable(false);
		view.getGraphPane().setLayout(new BorderLayout());
		view.getGraphPane().add(graphComponent, BorderLayout.CENTER);
		view.getGraphPane().validate();
		initZoomListeners(graphComponent);
	}
	
	
			for(int x: this.midBlockTargets) {
			Iterator<BasicBlock> itr4 = this.blockList.values().iterator();
			while (itr4.hasNext()) {
				BasicBlock temp = itr4.next();
				if(temp.containsAddress(x+0x400000)) {
					HashSet<Integer> initialAddrReferences = new HashSet<Integer>();
					HashSet<Integer> initialLoopReferences = new HashSet<Integer>();
					initialLoopReferences.addAll(temp.getLoopAddressReferences());
					initialAddrReferences.addAll(temp.getAddressReferenceList());
					for(int i:initialAddrReferences) {
						System.out.println(Integer.toHexString(i-0x400000));
					}
					// Split the blocks instructions into two lists to assign to new blocks
					ArrayList<Capstone.CsInsn> initialInsns = new ArrayList<Capstone.CsInsn>(temp.getInstructionList().subList(0, temp.indexOfAddress(x+0x400000)));
					ArrayList<Capstone.CsInsn> targetList = new ArrayList<Capstone.CsInsn>(temp.getInstructionList().subList(temp.indexOfAddress(x+0x400000), temp.getInstructionList().size()));
					System.out.println(Long.toHexString(x)+" block found::::: ");
					System.out.print(temp.instructionsToString());
					System.out.println("first list: ");
					for(Capstone.CsInsn i:initialInsns) {
						System.out.println(i.mnemonic+"   "+i.opStr);
					}
					System.out.println("jump list: ");
					for(Capstone.CsInsn i:targetList) {
						System.out.println(i.mnemonic+"   "+i.opStr);
					}
					System.out.println();
					// Reset original lists' references and instructions, overwriting with initialInsn
					// and adding reference to the first address of the new list...
					this.blockList.get(temp.getFirstAddress()).overwriteInstructions(initialInsns, (int) targetList.get(0).address);
					System.out.println(this.blockList.get(temp.getFirstAddress()).instructionsToString());
					BasicBlock jumpBlock = new BasicBlock(); // to hold instructions at and after split
					jumpBlock.setInstructionList(targetList);
					jumpBlock.setReferences(initialAddrReferences);
					jumpBlock.setLoopReferences(initialLoopReferences);
					System.out.println(jumpBlock.instructionsToString());

				}
			}
		}